!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	ray.h	/^        vec3 A;$/;"	m	class:ray
AABBH	aabb.h	/^#define AABBH$/;"	d
B	ray.h	/^        vec3 B;$/;"	m	class:ray
BVHNODEH	bvh_node.h	/^#define BVHNODEH$/;"	d
CAMERAH	camera.h	/^#define CAMERAH$/;"	d
HITABLEH	hitable.h	/^#define HITABLEH$/;"	d
HITABLELISTH	hitable_list.h	/^#define HITABLELISTH$/;"	d
MATERIALH	material.h	/^#define MATERIALH$/;"	d
PERLINH	perlin.h	/^#define PERLINH$/;"	d
RAYH	ray.h	/^#define RAYH$/;"	d
SPHEREH	sphere.h	/^#define SPHEREH$/;"	d
TEXTUREH	texture.h	/^#define TEXTUREH$/;"	d
VEC3H	vec3.h	/^#define VEC3H$/;"	d
_max	aabb.h	/^        vec3 _min, _max;$/;"	m	class:aabb
_min	aabb.h	/^        vec3 _min, _max;$/;"	m	class:aabb
_time	ray.h	/^        float _time;$/;"	m	class:ray
aabb	aabb.h	/^        aabb() {}$/;"	f	class:aabb
aabb	aabb.h	/^        aabb(const vec3& a, const vec3& b) { _min = a; _max = b; }$/;"	f	class:aabb
aabb	aabb.h	/^class aabb {$/;"	c
albedo	material.h	/^        texture *albedo;$/;"	m	class:lambertian
albedo	material.h	/^        vec3 albedo;$/;"	m	class:metal
b	vec3.h	/^    inline float b() const { return e[2]; }$/;"	f	class:vec3
bounding_box	bvh_node.h	/^bool bvh_node::bounding_box(float t0, float t1, aabb& b) const {$/;"	f	class:bvh_node
bounding_box	hitable_list.h	/^bool hitable_list::bounding_box(float t0, float t1, aabb& box) const {$/;"	f	class:hitable_list
bounding_box	sphere.h	/^bool moving_sphere::bounding_box(float t0, float t1, aabb& box) const {$/;"	f	class:moving_sphere
bounding_box	sphere.h	/^bool sphere::bounding_box(float t0, float t1, aabb& box) const {$/;"	f	class:sphere
box	bvh_node.h	/^        aabb box;$/;"	m	class:bvh_node
box_x_compare	bvh_node.h	/^int box_x_compare(const void * a, const void * b) {$/;"	f
box_y_compare	bvh_node.h	/^int box_y_compare(const void * a, const void * b) {$/;"	f
box_z_compare	bvh_node.h	/^int box_z_compare(const void * a, const void * b) {$/;"	f
bvh_node	bvh_node.h	/^        bvh_node() {}$/;"	f	class:bvh_node
bvh_node	bvh_node.h	/^bvh_node::bvh_node(hitable **l, int n, float time0, float time1) {$/;"	f	class:bvh_node
bvh_node	bvh_node.h	/^class bvh_node : public hitable {$/;"	c
camera	camera.h	/^        camera(vec3 lookfrom, vec3 lookat, vec3 vup,$/;"	f	class:camera
camera	camera.h	/^class camera {$/;"	c
center	sphere.h	/^        vec3 center;$/;"	m	class:sphere
center	sphere.h	/^vec3 moving_sphere::center(float time) const {$/;"	f	class:moving_sphere
center0	sphere.h	/^        vec3 center0, center1;$/;"	m	class:moving_sphere
center1	sphere.h	/^        vec3 center0, center1;$/;"	m	class:moving_sphere
checker_texture	texture.h	/^        checker_texture() {}$/;"	f	class:checker_texture
checker_texture	texture.h	/^        checker_texture(texture *t0, texture *t1): even(t0), odd(t1) {}$/;"	f	class:checker_texture
checker_texture	texture.h	/^class checker_texture : public texture {$/;"	c
color	main.cpp	/^vec3 color(const ray& r, hitable *world, int depth) {$/;"	f
color	texture.h	/^        vec3 color;$/;"	m	class:constant_texture
constant_texture	texture.h	/^        constant_texture() {}$/;"	f	class:constant_texture
constant_texture	texture.h	/^        constant_texture(vec3 c) : color(c) {}$/;"	f	class:constant_texture
constant_texture	texture.h	/^class constant_texture : public texture {$/;"	c
cross	vec3.h	/^inline vec3 cross(const vec3 &v1, const vec3 &v2) {$/;"	f
dielectric	material.h	/^        dielectric(float ri) : ref_idx(ri) {}$/;"	f	class:dielectric
dielectric	material.h	/^class dielectric : public material {$/;"	c
direction	ray.h	/^        vec3 direction() const { return B; }$/;"	f	class:ray
dot	vec3.h	/^inline float dot(const vec3 &v1, const vec3 &v2) {$/;"	f
e	vec3.h	/^    float e[3];$/;"	m	class:vec3
even	texture.h	/^        texture *even;$/;"	m	class:checker_texture
ffmax	aabb.h	/^inline float ffmax(float a, float b) { return a > b ? a : b; }$/;"	f
ffmin	aabb.h	/^inline float ffmin(float a, float b) { return a < b ? a : b; }$/;"	f
fuzz	material.h	/^        float fuzz;$/;"	m	class:metal
g	vec3.h	/^    inline float g() const { return e[1]; }$/;"	f	class:vec3
get_ray	camera.h	/^        ray get_ray(float s, float t) {$/;"	f	class:camera
hit	aabb.h	/^        bool hit(const ray& r, float tmin, float tmax) const {$/;"	f	class:aabb
hit	bvh_node.h	/^bool bvh_node::hit(const ray& r, float t_min, float t_max, hit_record& rec) const {$/;"	f	class:bvh_node
hit	hitable_list.h	/^bool hitable_list::hit(const ray& r, float t_min, float t_max, hit_record& rec) const {$/;"	f	class:hitable_list
hit	sphere.h	/^bool moving_sphere::hit(const ray& r, float t_min, float t_max, hit_record& rec) const {$/;"	f	class:moving_sphere
hit	sphere.h	/^bool sphere::hit(const ray& r, float t_min, float t_max, hit_record& rec) const {$/;"	f	class:sphere
hit_record	hitable.h	/^struct hit_record {$/;"	s
hitable	hitable.h	/^class hitable {$/;"	c
hitable_list	hitable_list.h	/^        hitable_list() {}$/;"	f	class:hitable_list
hitable_list	hitable_list.h	/^        hitable_list(hitable **l, int n) { list = l; list_size = n; }$/;"	f	class:hitable_list
hitable_list	hitable_list.h	/^class hitable_list: public hitable {$/;"	c
horizontal	camera.h	/^        vec3 horizontal;$/;"	m	class:camera
lambertian	material.h	/^        lambertian(texture *a) : albedo(a) {}$/;"	f	class:lambertian
lambertian	material.h	/^class lambertian : public material {$/;"	c
left	bvh_node.h	/^        hitable *left;$/;"	m	class:bvh_node
length	vec3.h	/^    inline float length() const {$/;"	f	class:vec3
lens_radius	camera.h	/^        float lens_radius;$/;"	m	class:camera
list	hitable_list.h	/^        hitable **list;$/;"	m	class:hitable_list
list_size	hitable_list.h	/^        int list_size;$/;"	m	class:hitable_list
lower_left_corner	camera.h	/^        vec3 lower_left_corner;$/;"	m	class:camera
main	main.cpp	/^int main() {$/;"	f
make_unit_vector	vec3.h	/^inline void vec3::make_unit_vector() {$/;"	f	class:vec3
mat_ptr	hitable.h	/^    material *mat_ptr;$/;"	m	struct:hit_record
mat_ptr	sphere.h	/^        material *mat_ptr;$/;"	m	class:moving_sphere
mat_ptr	sphere.h	/^        material* mat_ptr;$/;"	m	class:sphere
material	material.h	/^class material {$/;"	c
max	aabb.h	/^        vec3 max() const { return _max; }$/;"	f	class:aabb
metal	material.h	/^        metal(const vec3& a) : albedo(a), fuzz(1) {}$/;"	f	class:metal
metal	material.h	/^        metal(const vec3& a, float f) : albedo(a) {$/;"	f	class:metal
metal	material.h	/^class metal : public material {$/;"	c
min	aabb.h	/^        vec3 min() const { return _min; }$/;"	f	class:aabb
moving_sphere	sphere.h	/^        moving_sphere() {}$/;"	f	class:moving_sphere
moving_sphere	sphere.h	/^        moving_sphere(vec3 cen0, vec3 cen1, float t0, float t1, float r, material *m)$/;"	f	class:moving_sphere
moving_sphere	sphere.h	/^class moving_sphere: public hitable {$/;"	c
noise	perlin.h	/^        float noise(const vec3& p) const {$/;"	f	class:perlin
noise	texture.h	/^        perlin noise;$/;"	m	class:noise_texture
noise_texture	texture.h	/^        noise_texture() {}$/;"	f	class:noise_texture
noise_texture	texture.h	/^        noise_texture(float sc) : scale(sc) {}$/;"	f	class:noise_texture
noise_texture	texture.h	/^class noise_texture : public texture {$/;"	c
normal	hitable.h	/^    vec3 normal;$/;"	m	struct:hit_record
odd	texture.h	/^        texture *odd;$/;"	m	class:checker_texture
operator *	vec3.h	/^inline vec3 operator*(const vec3 &v, float t) {$/;"	f
operator *	vec3.h	/^inline vec3 operator*(const vec3 &v1, const vec3 &v2) {$/;"	f
operator *	vec3.h	/^inline vec3 operator*(float t, const vec3 &v) {$/;"	f
operator *=	vec3.h	/^inline vec3& vec3::operator*=(const float t) {$/;"	f	class:vec3
operator *=	vec3.h	/^inline vec3& vec3::operator*=(const vec3 &v) {$/;"	f	class:vec3
operator +	vec3.h	/^    inline const vec3& operator+() const { return *this; }$/;"	f	class:vec3
operator +	vec3.h	/^inline vec3 operator+(const vec3 &v1, const vec3 &v2) {$/;"	f
operator +=	vec3.h	/^inline vec3& vec3::operator+=(const vec3 &v) {$/;"	f	class:vec3
operator -	vec3.h	/^    inline vec3 operator-() const { return vec3(-e[0], -e[1], -e[2]); }$/;"	f	class:vec3
operator -	vec3.h	/^inline vec3 operator-(const vec3 &v1, const vec3 &v2) {$/;"	f
operator -=	vec3.h	/^inline vec3& vec3::operator-=(const vec3 &v) {$/;"	f	class:vec3
operator /	vec3.h	/^inline vec3 operator\/(const vec3 &v1, const vec3 &v2) {$/;"	f
operator /	vec3.h	/^inline vec3 operator\/(vec3 v, float t) {$/;"	f
operator /=	vec3.h	/^inline vec3& vec3::operator\/=(const float t) {$/;"	f	class:vec3
operator /=	vec3.h	/^inline vec3& vec3::operator\/=(const vec3 &v) {$/;"	f	class:vec3
operator <<	vec3.h	/^inline std::ostream& operator<<(std::ostream &os, const vec3 &t) {$/;"	f
operator >>	vec3.h	/^inline std::istream& operator>>(std::istream &is, vec3 &t) {$/;"	f
operator []	vec3.h	/^    inline float operator[](int i) const { return e[i]; }$/;"	f	class:vec3
operator []	vec3.h	/^    inline float& operator[](int i) { return e[i]; }$/;"	f	class:vec3
origin	camera.h	/^        vec3 origin;$/;"	m	class:camera
origin	ray.h	/^        vec3 origin() const { return A; }$/;"	f	class:ray
p	hitable.h	/^    vec3 p;$/;"	m	struct:hit_record
perlin	perlin.h	/^class perlin {$/;"	c
perlin_generate	perlin.h	/^static vec3* perlin_generate() {$/;"	f
perlin_generate_perm	perlin.h	/^static int* perlin_generate_perm() {$/;"	f
perline_interp	perlin.h	/^inline float perline_interp(vec3 c[2][2][2], float u, float v, float w) {$/;"	f
perm_x	perlin.h	/^        static int *perm_x;$/;"	m	class:perlin
perm_x	perlin.h	/^int *perlin::perm_x = perlin_generate_perm();$/;"	m	class:perlin
perm_y	perlin.h	/^        static int *perm_y;$/;"	m	class:perlin
perm_y	perlin.h	/^int *perlin::perm_y = perlin_generate_perm();$/;"	m	class:perlin
perm_z	perlin.h	/^        static int *perm_z;$/;"	m	class:perlin
perm_z	perlin.h	/^int *perlin::perm_z = perlin_generate_perm();$/;"	m	class:perlin
permute	perlin.h	/^void permute(int *p, int n) {$/;"	f
point_at_parameter	ray.h	/^        vec3 point_at_parameter(float t) const { return A + t * B; }$/;"	f	class:ray
r	vec3.h	/^    inline float r() const { return e[0]; }$/;"	f	class:vec3
radius	sphere.h	/^        float radius;$/;"	m	class:moving_sphere
radius	sphere.h	/^        float radius;$/;"	m	class:sphere
random_in_unit_disk	camera.h	/^vec3 random_in_unit_disk() {$/;"	f
random_in_unit_sphere	material.h	/^vec3 random_in_unit_sphere() {$/;"	f
random_scene	main.cpp	/^hitable *random_scene() {$/;"	f
ranvec	perlin.h	/^        static vec3 *ranvec;$/;"	m	class:perlin
ranvec	perlin.h	/^vec3 *perlin::ranvec = perlin_generate();$/;"	m	class:perlin
ray	ray.h	/^        ray() {}$/;"	f	class:ray
ray	ray.h	/^        ray(const vec3& a, const vec3& b, float ti = 0.0) : A(a), B(b), _time(ti) {}$/;"	f	class:ray
ray	ray.h	/^class ray {$/;"	c
ref_idx	material.h	/^        float ref_idx;$/;"	m	class:dielectric
reflect	material.h	/^vec3 reflect(const vec3& v, const vec3& n) {$/;"	f
refract	material.h	/^bool refract(const vec3& v, const vec3& n, float ni_over_nt, vec3& refracted) {$/;"	f
right	bvh_node.h	/^        hitable *right;$/;"	m	class:bvh_node
scale	texture.h	/^        float scale;$/;"	m	class:noise_texture
scatter	material.h	/^        virtual bool scatter(const ray& r_in, const hit_record& rec, vec3& attenuation, ray& scattered) const {$/;"	f	class:dielectric
scatter	material.h	/^        virtual bool scatter(const ray& r_in, const hit_record& rec, vec3& attenuation, ray& scattered) const {$/;"	f	class:lambertian
scatter	material.h	/^        virtual bool scatter(const ray& r_in, const hit_record& rec, vec3& attenuation, ray& scattered) const {$/;"	f	class:metal
schlick	material.h	/^float schlick(float cosine, float ref_idx) {$/;"	f
sphere	sphere.h	/^        sphere() {}$/;"	f	class:sphere
sphere	sphere.h	/^        sphere(vec3 cen, float r, material *mat) : center(cen), radius(r), mat_ptr(mat) {};$/;"	f	class:sphere
sphere	sphere.h	/^class sphere : public hitable {$/;"	c
squared_length	vec3.h	/^    inline float squared_length() const {$/;"	f	class:vec3
surrounding_box	aabb.h	/^aabb surrounding_box(aabb box0, aabb box1) {$/;"	f
t	hitable.h	/^    float t;$/;"	m	struct:hit_record
texture	texture.h	/^class texture {$/;"	c
time	ray.h	/^        float time() const { return _time; }$/;"	f	class:ray
time0	camera.h	/^        float time0, time1; \/\/ shutter open\/close time$/;"	m	class:camera
time0	sphere.h	/^        float time0, time1;$/;"	m	class:moving_sphere
time1	camera.h	/^        float time0, time1; \/\/ shutter open\/close time$/;"	m	class:camera
time1	sphere.h	/^        float time0, time1;$/;"	m	class:moving_sphere
two_perlin_spheres	main.cpp	/^hitable *two_perlin_spheres() {$/;"	f
u	camera.h	/^        vec3 u, v, w;$/;"	m	class:camera
unit_vector	vec3.h	/^inline vec3 unit_vector(vec3 v) {$/;"	f
v	camera.h	/^        vec3 u, v, w;$/;"	m	class:camera
value	texture.h	/^        virtual vec3 value(float u, float v, const vec3& p)  const {$/;"	f	class:checker_texture
value	texture.h	/^        virtual vec3 value(float u, float v, const vec3& p) const {$/;"	f	class:constant_texture
value	texture.h	/^        virtual vec3 value(float u, float v, const vec3& p) const {$/;"	f	class:noise_texture
vec3	vec3.h	/^    vec3() {}$/;"	f	class:vec3
vec3	vec3.h	/^    vec3(float e0, float e1, float e2) { e[0] = e0; e[1] = e1; e[2] = e2; }$/;"	f	class:vec3
vec3	vec3.h	/^class vec3  {$/;"	c
vertical	camera.h	/^        vec3 vertical;$/;"	m	class:camera
w	camera.h	/^        vec3 u, v, w;$/;"	m	class:camera
x	vec3.h	/^    inline float x() const { return e[0]; }$/;"	f	class:vec3
y	vec3.h	/^    inline float y() const { return e[1]; }$/;"	f	class:vec3
z	vec3.h	/^    inline float z() const { return e[2]; }$/;"	f	class:vec3
